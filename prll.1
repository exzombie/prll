." Text automatically generated by txt2man
.TH prll 1 "29 October 2011" "prll-0.6.2" ""
.SH NAME
\fBprll \fP- parallelize execution of shell functions
.SH SYNOPSIS
.nf
.fam C
\fBprll\fP [ \fB-b\fP | \fB-B\fP ] [ \fB-c\fP \fInum\fP ] [ \fB-q\fP | \fB-Q\fP ] { \fB-s\fP \fIstr\fP | \fIfunct\fP } { \fB-p\fP | \fB-0\fP | \fIargs\fP }

.fam T
.fi
.fam T
.fi
.SH DESCRIPTION

\fBprll\fP (pronounced "parallel") is a utility for use with sh-compatible
shells, such as \fBbash\fP(1), \fBzsh\fP(1) and \fBdash\fP(1). It provides a
convenient interface for parallelizing the execution of a single
task over multiple data files, or actually any kind of data that you
can pass as a shell function argument. It is meant to make it simple
to fully utilize a multicore/multiprocessor machine, or to just run
long running tasks in parallel. Its distinguishing feature is the
ability to run shell functions in the context of the current shell.
.SH OPTIONS
.TP
.B
\fB-s\fP \fIstr\fP
Use string \fIstr\fP as shell code to run.
.TP
.B
\fB-b\fP
Disable output buffering.
.TP
.B
\fB-B\fP
Enable output buffering, which is the default.
Use to override the PRLL_BUFFER variable.
.TP
.B
\fB-p\fP
Read arguments as lines from standard input instead
of command line.
.TP
.B
\fB-0\fP
Same as \fB-p\fP, but use the null character as delimiter
instead of newline.
.TP
.B
\fB-c\fP \fInum\fP
Set number of parallel jobs to \fInum\fP. This overrides
the PRLL_NRJOBS variable and disables checking
of /proc/cpuinfo.
.TP
.B
\fB-q\fP
Disable progress messages.
.TP
.B
\fB-Q\fP
Disable all messages except errors.
.SH ENVIRONMENT

.TP
.B
PRLL_BUFFER
Set to 'no' or '0' to disable output buffering.
.TP
.B
PRLL_NRJOBS
Set to the number of parallel jobs to run. If set,
it disables checking of /proc/cpuinfo.
.TP
.B
PRLL_NR_CPUS
Deprecated in favor of PRLL_NRJOBS.
.SH RESERVED SHELL SYMBOLS

All names beginning with 'prll_' are reserved and should not be
used. The following are intended for use in user supplied
functions:
.TP
.B
prll_interrupt
Cause \fBprll\fP to stop running new jobs. It will wait
for running jobs to complete and then exit.
.TP
.B
prll_seq
A simple substitute for \fBseq\fP(1). With one argument
prints numbers from 1 up to the argument. With two
arguments prints numbers from the first up to the
second argument.
.TP
.B
prll_lock
Acquires a lock. There are 5 locks available,
numbered from 0 to 4. If the lock is already taken,
waits until it is available. Defaults to lock 0
when no argument is given
.TP
.B
prll_unlock
Release a lock taken with prll_lock. Defaults to
lock 0 when no argument is given.
.TP
.B
prll_splitarg
Splits a quoted argument according to shell
rules. The words are assigned to variables named
prll_arg_X, where X numbers them from 1 upwards.
.TP
.B
prll_arg_
Variables that hold arguments as generated by
prll_splitarg.
.TP
.B
prll_arg_num
A variable containing the number of prll_arg_
variables, as generated by prll_splitarg.
.TP
.B
prll_jobnr
A variable containing the current job's number. It
starts counting from zero.
.SH OPERATION

\fBprll\fP is designed to be used not just in shell scripts, but
especially in interactive shells. To make the latter convenient, it
is implemented as a shell function. This means that it inherits the
whole environment of your current shell. It uses helper programs,
written in C. To prevent race conditions, System V Message Queues
and Semaphores are used to signal job completion. It also features
full output buffering to prevent mangling of data because of
concurrent output.
.SS USAGE

To execute a task, create a shell function that does something to
its first argument. Pass that function to \fBprll\fP along with the
arguments you wish to execute it on.
.PP
As an alternative, you may pass the \fB-s\fP flag, followed by a
string. The string will be executed as if it were the body of a
shell function. Therefore, you may use '$1' to reference its first
(and only) argument. Be sure to quote the string properly to
prevent shell expansion.
.PP
Instead of arguments, you can use options \fB-p\fP or \fB-0\fP. \fBprll\fP will then
take its arguments from stdin. The \fB-p\fP flag will make it read lines
and the \fB-0\fP flag will make it read null-delimited input. This mode
emulates the \fBxargs\fP(1) utility a bit, but is easier for interactive
use because \fBxargs\fP(1) makes it hard to pass complex commands. Reading
large arguments (such as lines several megabytes long) in this
fashion is slow, however. If your data comes in such large chunks,
it is much faster to split it into several files and pass a list of
those to \fBprll\fP instead.
.PP
The \fB-b\fP option disables output buffering. See below for
explanation. Alternatively, buffering may be disabled by setting the
PRLL_BUFFER environment variable to 'no'. Use the \fB-B\fP option to
override this.
.PP
The \fB-q\fP and \fB-Q\fP options provide two levels of quietness. Both suppress
progress reports. The \fB-Q\fP option also disables the startup and end
messages. They both let errors emited by your jobs through.
.PP
The number of tasks to be run in parallel is provided with the \fB-c\fP
option or via the PRLL_NRJOBS environment variable. If it is not
provided, \fBprll\fP will look into the /proc/cpuinfo file and extract the
number of CPUs in your computer.
.SS SUSPENDING AND ABORTING

Execution can be suspended normally using Ctrl+Z. \fBprll\fP should be
subject to normal job control, depending on the shell.
.PP
If you need to abort execution, you can do it with the usual Ctrl+C
key combination. \fBprll\fP will wait for remaining jobs to complete
before exiting. If the jobs are hung and you wish to abort
immediately, use Ctrl+Z to suspend \fBprll\fP and then kill it using your
shell's job control.
.PP
The command prll_interrupt is available from within your
functions. It causes \fBprll\fP to abort execution in the same way as
Ctrl+C.
.SS CLEANUP

\fBprll\fP cleans after itself, except when you force termination. If you
kill \fBprll\fP, jobs and stale message queues and semaphores will be left
lying around. The jobs' PIDs are printed during execution so you can
track them down and terminate them. You can list the queues and
semaphores using the \fBipcs\fP(1) command and remove them with the
\fBipcrm\fP(1) command. Refer to your system's documentation for
details. Be aware that other programs might (and often do) make use
of IPC facilities, so make sure you remove the correct queue or
semaphore. Their keys are printed when \fBprll\fP starts.
.SS BUFFERING

Transport of data between programs is normally buffered by the
operating system. These buffers are small (e.g. 4kB on Linux), but
are enough to enhance performance. Multiple programs writing to the
same destination, as is the case with \fBprll\fP, is then arranged like
this:
.PP
.nf
.fam C
    +-----+    +-----------+
    | job |--->| OS buffer |\\
    +-----+    +-----------+ \\
                              \\
    +-----+    +-----------+   \\+-------------+
    | job |--->| OS buffer |--->| Output/File |
    +-----+    +-----------+   /+-------------+
                              /
    +-----+    +-----------+ /
    | job |--->| OS buffer |/
    +-----+    +-----------+

.fam T
.fi
The output can be passed to another program, over a network or into
a file. But the jobs run in parallel, so the question is: what will
the data they produce look like at the destination when they write
it at the same time?
.PP
If a job writes less data than the size of the OS buffer, then
everything is fine: the buffer is never filled and the OS flushes it
when the job exits. All output from that job is in one piece because
the OS will flush only one buffer at a time.
.PP
If, however, a job writes more data than that, then the OS flushes
the buffer each time it is filled. Because several jobs run in
parallel, their outputs become interleaved at the destination, which
is not good.
.PP
\fBprll\fP does additional job output buffering by default. The actual
arrangement when running \fBprll\fP looks like this:
.PP
.nf
.fam C
    +-----+    +-----------+    +-------------+
    | job |--->| OS buffer |--->| prll buffer |\\
    +-----+    +-----------+    +-------------+ \\
                                       |         \\
    +-----+    +-----------+    +-------------+   \\+-------------+
    | job |--->| OS buffer |--->| prll buffer |--->| Output/File |
    +-----+    +-----------+    +-------------+   /+-------------+
                                       |         /
    +-----+    +-----------+    +-------------+ /
    | job |--->| OS buffer |--->| prll buffer |/
    +-----+    +-----------+    +-------------+

.fam T
.fi
Note the vertical connections between \fBprll\fP buffers: they synchronise
so that they only write data to the destination one at a time. They
make sure that all of the output of a single job is in one piece. To
keep performance high, the jobs must keep running, therefore each
buffer must be able to keep taking in data, even if it cannot
immediately write it. To make this possible, \fBprll\fP buffers aren't
limited in size: they grow to accomodate all data a job produces.
.PP
This raises another concern: you need to have enough memory to
contain the data until it can be written. If your jobs produce more
data than you have memory, you need to redirect it to files. Have
each job create a file and redirect all its output to that file. You
can do that however you want, but there should be a helpful utility
available on your system: \fBmktemp\fP(1). It is dedicated to creating
files with unique names. The prll_jobnr variable can also be used.
.PP
As noted in the usage instructions, \fBprll\fP's additional buffering can
be disabled. It is not necessary to do this when each job writes to
its own file. It is meant to be used as a safety measure. \fBprll\fP was
written with interactive use in mind, and when writing functions on
the fly, it can easily happen that an error creeps in. If an error
causes spurious output (e.g. if the function gets stuck in an
infinite loop) it can easily waste a lot of memory. The option to
disable buffering is meant to be used when you believe that your
jobs should only produce a small amount of data, but aren't sure
that they actually will.
.PP
It should be noted that buffering only applies to standard
output. OS buffers standard error differently (i.e. by lines) and
\fBprll\fP does nothing to change that.
.SS EXAMPLES

Suppose you have a set of photos that you wish to process using the
\fBmogrify\fP(1) utility. Simply do
.PP
.nf
.fam C
    myfn() { mogrify -flip $1 ; }
    prll myfn *.jpg

.fam T
.fi
This will run mogrify on each jpg file in the current directory. If
your computer has 4 processors, but you wish to run only 3 tasks at
once, you should use
.PP
.nf
.fam C
    prll -c 3 myfn *.jpg

.fam T
.fi
Or, to make it permanent in the current shell, do
.PP
.nf
.fam C
    PRLL_NRJOBS=3

.fam T
.fi
on a line of its own. You don't need to export the variable because
\fBprll\fP automatically has access to everything your shell can see.
.PP
All examples here are very short. Unless you need it later, it is
quicker to pass such a short function on the command line directly:
.PP
.nf
.fam C
    prll -s 'mogrify -flip $1' *.jpg

.fam T
.fi
\fBprll\fP now automatically wraps the code in an internal function so you
don't have to. Don't forget about the single quotes, or the shell
will expand $1 before \fBprll\fP is run.
.PP
If you have a more complicated function that has to take more than
one argument, you can use a trick: combine multiple arguments into
one when passing them to \fBprll\fP, then split them again inside your
function. You can use shell quoting to achieve that. Inside your
function, prll_splitarg is available to take the single argument
apart again, i.e.
.PP
.nf
.fam C
    myfn() {
      prll_splitarg
      process $prll_arg_1
      compute $prll_arg_2
      mangle $prll_arg_3
    }
    prll myfn 'a1 b1 c1' 'a2 b2 c3' 'a3 b3 c3' \.\.\.

.fam T
.fi
If you have even more complex requirements, you can use the '\fB-0\fP'
option and pipe null-delimited data into \fBprll\fP, then split it any way
you want. Modern shells have powerful \fBread\fP(1) builtins.
.PP
You may wish to abort execution if one of the results is wrong. In
that case, use something like this:
.PP
.nf
.fam C
    myfn() { compute $1; [[ $result == "wrong" ]] && prll_interrupt; }

.fam T
.fi
This is useful also when doing anything similar to a parallel
search: abort execution when the result is found.
.PP
If you have many arguments to process, it might be easier to pipe
them to standard input. Suppose each line of a file is an argument
of its own. Simply pipe the file into \fBprll\fP:
.PP
.nf
.fam C
    myfn() { some; processing | goes && on; here; }
    cat file_with_arguments | prll myfn -p > results

.fam T
.fi
Remember that it's not just CPU-intensive tasks that benefit from
parallel excution. You may have many files to download from several
slow servers, in which case, the following might be useful:
.PP
.nf
.fam C
    prll -c 10 -s 'wget -nv "$1"' -p < links.txt

.fam T
.fi
You may wish to observe \fBprll\fP's progress in your terminal, but
collect your jobs' non-data output in a single file. Since opening a
file from multiple parallel jobs is unsafe, you should protect it
with a lock, i.e.
.PP
.nf
.fam C
    myfn() {
      compute_stuff $1
      prll_lock 0
      echo "Job $prll_jobnr report:" >> jobreports.txt
      write_report >> jobreports.txt
      echo "-----------------------" >> jobreports.txt
      prll_unlock 0
      return $jobstatus
    }

.fam T
.fi
This function uses lock number 0 to protect the jobreports.txt file
so that it is written by only one job at a time. There are several
locks available. Be sure to release them, otherwise the jobs will
hang waiting for one another. The prll_jobnr variable is used to
denote each report.
.SH BUGS

This section describes issues and bugs that were known at the time
of release. Check the homepage for more current information.
.PP
Known issues:
.IP \(bu 3
In zsh, the Ctrl+C combination forces \fBprll\fP into the background.
.IP \(bu 3
User should be able to limit buffer memory usage, but still use
buffering without loss of data. Is this possible to solve
elegantly?
.IP \(bu 3
The test suite should be expanded. Specifically, termination
behaviour on external interrupt signal currently currently has to
be checked manually. Also, checking of stderr output is not done.
.IP \(bu 3
Cross-compilation should be documented and made easier.
.IP \(bu 3
Shell's job table becomes saturated with a large number of jobs.
This is not really an issue, since it happens when the number of
jobs is above 500 or so. Nevertheless, it might be possible to
disown jobs if such a large number of them should be required.
.SH SEE ALSO
\fBsh\fP(1), \fBxargs\fP(1), \fBmktemp\fP(1), \fBipcs\fP(1), \fBipcrm\fP(1), \fBsvipc\fP(7)
.PP
Homepage: http://prll.sourceforge.net/
.SH AUTHOR
Jure Varlec <jure.varlec@gmail.com>
