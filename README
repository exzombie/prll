prll
version 0.1
================

prll is a utility for use with bash or zsh. It provides a convenient
interface for parallelizing the execution of a single task over
multiple data files, or actually any kind of data that you can pass as
a function argument. It is meant to make it simple to fully utilize a
multicore/multiprocessor machine.

Homepage: http://prll.sourceforge.net/


DESCRIPTION
-----------

prll is designed to be used not just in shell scripts, but also in
interactive shells. To make the latter convenient, it is implemented
as a shell function. Shells are not much good at automatic job
management; see [1] for further discussion. Therefore, prll uses a
jobserver, written in C. To prevent race conditions, System V Message
Queues are used to signal job completion.

[1] http://prll.sourceforge.net/shell_parallel.html


REQUIREMENTS
------------

  - bash or zsh
  - C compiler, such as gcc
  - OS support for System V Message Queues; GNU/Linux will do fine
  - programs awk, sed, egrep, ipcs, ipcrm and ipcmk

For now, prll has only been tested on GNU/Linux. It might need minor,
simple modifications on other systems, like replacing egrep with a
different grep implementation.

prll also looks for the /proc/cpuinfo file. It uses it to
automatically determine the number of processors. Non-Linux systems
may lack this file or have a different syntax. Setting the
PRLL_NR_CPUS environment variable renders the cpuinfo file unnecessary
(see usage instructions below).

INSTALLATION
------------

Compile prll_jobserver.c. You can use the included Makefile. If you
have gcc, you can simply run

  make

If you have gcc and want different compiler options, do

  CFLAGS=whatever make

If you have a different compiler, you may want to completely override
compiler options, like so

  make CFLAGS=whatever

When this is done, copy the prll_jobserver executable to a directory
you have in your PATH. For example, to do a system-wide installation,
run as root

  chown root:root prll_jobserver
  cp prll_jobserver /usr/local/bin/

File prll.sh contains the shell function. The shell that will use it
needs to source it. That means that: 
  - If you wish to use prll in a shell script, simply copy it in there.
  - If you wish to use prll in an interactive shell, source it.
The latter means that you need to put the function somewhere where
your shell will find it. If you are installing it for yourself, put
it in your .bashrc or .zshrc. If you are installing it system-wide, put
it in /etc/profile. However, if your system has the /etc/profile.d
directory, use that. For example

  chown root:root prll.sh
  cp prll.sh /etc/profile.d/

The function should now be automatically sourced by login shells. To
have every instance of bash source it, insert

  source /etc/profile

into your .bashrc.


USAGE
-----

Synopsis: prll function_name arguments ...

To execute a task, create a shell function that does something to its
first argument. Pass that function to prll along with the arguments
you wish to execute it on.

The number of tasks to be run in parallel is provided via the
PRLL_NR_CPUS environment variable. If it is not provided, prll will
look into the /proc/cpuinfo file and extract the number of CPUs in
your computer.

If you need to abort the execution, the message queue created for
communication will probably be left to linger. You can list the queues
with the 'ipcs' command and remove them with the 'ipcrm'
command. Refer to your system's documentation for details.


Examples:

Suppose you have a set of photos that you wish to process using the
'mogrify' utility. Simply do

  function myfn() { mogrify -flip $1 ; }
  prll myfn *.jpg

This will run mogrify on each jpg file in the current directory. If
your computer has 4 processors, but you wish to run only 3 tasks at
once, you should use

  PRLL_NR_CPUS=3 prll myfn *.jpg

Or, to make it permanent in the current shell, do

  export PRLL_NR_CPUS=3


To make things shorter, you can leave out the 'function' keyword when
defining a function. To redefine the same example:

  myfn() { mogrify -flip $1 ; }

However, you now need to be careful not to forget the parentheses. When
using the 'function' keyword, they are optional. If you leave it out,
they are not.


If you have a more complicated function that has to take more than one
argument, you should use a trick: combine multiple arguments into one
when passing them to prll, then split them again inside your
function. Here is a stub for a function that takes three arguments:

  function myfn() { echo $1 | read a b c; process $a; compute $b; kill $c; }
  prll myfn 'a1 b1 c1' 'a2 b2 c3' 'a3 b3 c3' ...


KNOWN ISSUES
------------

- Forcing of the ksharrays option.
  The ksharrays option for zsh should not be forced on. Turning it on
  only for the duration of the function causes trouble if the function
  is aborted. This might/should be handled by modifying array indexing.

- Handle termination gracefully.
  Currently, terminating prll execution prematurely leaves behind a
  message queue. Cleanup should be done on SIGINT. This may also help
  solve the ksharrays issue. However, care should be taken when
  handling signals -- make sure the jobserver passes the signal to the
  shell, which can do the cleanup in a trap. Test for reliability.

- Missing 'make test' target.
  Tests should be added to make it easy to check whether the package
  works reliably or at all.

- Have an option to pass parameters on stdin.
  Passing a very long list of arguments would be simpler, especially
  when the function takes more than one argument.

- Have an option to pass code in a string instead of a function.
  If code to be executed is short, passing it as a string would make
  interactive use quicker.

- Checking for the size of key_t in the jobserver is ugly.
  Put that check into a separate file and have 'make' check it at
  build time. Also do build time checks for all necessary utilities.

- Make prll a standalone program.
  Having prll as a standalone program would allow for a cleaner
  implementation without a jobserver. However, it would complicate
  interactive use, because code could only be passed in separate shell
  scripts or as strings, which is not as flexible.
  This issue can only be solved by finding a way to make interactive
  usage of a standalone program simple.


LICENSING INFORMATION
---------------------

The user needs to be able to include the prll shell function in his
own work, which might be anything. Therefore, the contents of prll.sh
are provided under the terms of the WTFPL, version 2. 
See COPYING.WTFPL-2 for more information.

The rest of the prll package is provided under the GNU General Public
License, version 3 or later. See COPYING.GPL-3 for more information.

Copyright 2009 Jure Varlec
